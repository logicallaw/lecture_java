/*
#강의 내용 정리
1.상속이란
부모클래스의 필드와 메서드를 자식 클래스가 물려받는 것을 말한다.

2.상속은 부모의 필드와 메서드를 받기 때문에
만약에 부모의 필드 또는 메서드를 수정하게 된다면
자식 클래스도 수정해야하기 때문에
코드 의존성이 높아진다.
따라서, 왠만하면 코딩할 때 최대한 독립적으로 코딩하는게 좋다.
그래야 코드 의존성이 낮아진다.

3.C++에서는 다중상속이 있지만, 자바에서는 없다.
다중상속은 코드 의존성을 낮춘다.

4.Composition Vs 상속
Composition은 상속보다 코드 의존성이 낮다.

5.자바에서 상속은 extends 부모 클래스로 상속받을 수 있다.

6.자식 클래스는 부모 클래스의 필드 중에서 private 접근 권한을 가진 필드
접근할 수 없다.

6-1.(기억)private은 무조건 해당 클래스 안에서만 가능하다.
(자식에서 사용x)

7.자식에서 부모의 public 메서드를 사용할 수 있다.

8.자바는 클래스의 다중 상속을 지원하지 않는다.
c++는 다중 상속을 지원하지만 다중상속을 잘 사용하지는 않는다.

9.상속의 최상위 조상 클래스는 java.lang.Object클래스이다.
모든 클래스의 최상위 부모가 Object 클래스라고 기억하면 된다.

10.슈퍼클래스, 서브클래스 = 부모클래스, 자식클래스

11.(기억)protected 멤버는 다른 패키지에 있어도
자식클래스에서 접근이 가능하다.
+)상속을 고려한 protected 코딩 습관은 좋지 않다.
코드 의존성이 높아지고, 코딩할 때는 접근권한을 줄이는 방향으로 해야한다.

12.(중요)객체의 생성은 곧 생성자의 호출이다.
자식 객체가 생성되면 곧 부모 생성자가 호출되고
부모 생성자가 실행되며 이후 마지막으로 자식 생성자가 실행된다.
그러므로, 자식 객체가 존재할 수 있게 된다.
이 과정에서 내부적으로 부모가 만들어졌기 때문이다.

13.(중요,기억, 규칙이라 기억해야됨)자식 클래스에서 부모클래스의 생성자를 선택하지 않는경우
기본적으로 컴파일러가 부모클래스의 기본생성자를 선택하게 된다.

14.자식클래스에서 부모클래스의 생성자를 선택하는 방법은
super(매개변수)를 사용하면 된다.
이때, super()는 반드시 자식클래스 생성자 코드의
제일 첫 라인에 와야한다.

15.is-a관계:
사람은 생물이다.(o)
생물은 사람이다.(x)
생물은 사람에 비해 큰 범위이다.
부모가 생물이고 사람이 자식이다.
이러한 상속관계이자 일방향 관계를 is-a관계라고 한다.

16.업캐스팅
사람(부모 클래스)
교수, 연구자, 학생 (서로 다른 타입, 자식클래스)

교수 p = new 교수();
연구자 r = new 연구자();
학생 s = new 학생();

지금 이 상태에서 서로 타입이 다르기 때문에
하나의 배열로 못 묶는다.
또한, 타입이 달라 반복문도 실행을 못하고
동일한 메서드에 대해
method(교수p);
method(연구자r);
method(학생s);
와 같이 중복이 많아진다.

이러한 한계를 부모 클래스 타입인 사람타입이면 가능하다.
즉, 
사람 p1 = new 교수();
사람 p2 = new 연구자();
사람 p3 = new 학생();
이러면 참조변수의 배열의 타입이 같아지게 되는데
부모 타입 가지고 자식 타입을 한 번에 처리할 수 있게 된다.
사람배열->[사람타입 p1, 사람타입 p2, 사람타입 p3]와 같이
배열로 묶을 수 있게 되고
각각은 서로 다른 타입의 자식 타입을 참조하게 된다.

그러면 반복문을 사용하여 method(사람 p)로 
서로 다른 타입의 자식들을 부모타입으로
한번에 method를 처리할 수 있게 된다.

이와 같은 방법을 업캐스팅이라고 한다.
(책에서는)업캐스팅이란 자식클래스의 객체를 부모클래스 타입으로 변환하는 것을 의미한다.
(책에서는)업캐스팅된 레퍼런스는 객체 내에 부모 클래스 멤버에만 접근이 가능하다.
예를 들면
부모 Person-자식 Student 관계에서
Student에서 Person으로 업캐스팅된 객체를 참조하는 변수가 있다고 생각할 때
해당 참조변수는 반드시 부모의 멤버만 접근이 가능하다.
자식 멤버에 접근하면 에러다.

Person
name, id

Student
grade, department

Person p1 = new Student();
p1.grade는 안된다. (컴파일 에러가 난다)
부모만 접근이 가능해서 p1.name만 가능하다.

17.다운캐스팅이란 부모타입에서 자식타입으로 변환하는 것을 의미한다.
다운캐스팅은 명시적으로 사용해야한다.

Person p = new Student(); //업캐스팅
Student s = (Student)p; //다운캐스팅
다운캐스팅된 참조변수 s는 s.자식멤버에 접근이 가능하다.
또한, ((Student)p).자식 멤버에 접근이 가능하다.
위 처럼 접근하면 반드시 괄호가 있어야한다.

18.다운캐스팅은 항상 조심해야한다.
다운캐스팅시 언제나 타입체크를 먼저해야한다.

만약에
부모 A
자식 B, C
A a = new B();//업캐스팅
(C)a->컴파일 에러는 안남. 다만 런타임 에러가 발생.

19.따라서, instanceof연산자가 존재하는데
객체레퍼런스 instanceof 클래스타입 ->true or false
객체레퍼런스가 클래스타입으로 변환 가능한지의 여부.

20.다형성
기본적으로 업캐스팅을 전제로하고
추가로 다운캐스팅시 타입검사를 해야한다.
 (gpt)
 1.다형성이란 두 가지 방식으로 표현되는데 첫번째로는
 서로 다른 클래스의 객체들이 같은 메시지를 전송했을 때 각각 다르게 반응하는 능력을 의미한다.
 이는 객체 지향 개념에 속한다.
 즉, 같은 이름 메서드가 서로 다른 클래스에서 서로 다른 기능을 수행할 수 있는 능력을 의미한다.
 메서드 오버로딩 또는 메서드 다형성이라고 한다.

 두번째로는 하나의 클래스 내에서도 다른 클래스와의 관계에서 다양한 형태로 동작할 수 있는 능력을 의미한다.
 이는 상속을 통해 구현되며 자식클래스가 부모클래스를 상속받으면 부모클래스의 메서드를 오버라이딩하여 다양한 형태로
 동작할 수 있게 된다.
 2.메서드 오버로딩은 컴파일 시간에 해결되지만 메서드 오버라이딩은 런타임 시간에 해결된다.

 2-1.'메서드 오버로딩'은 같은 이름을 가진 여러 메서드를 한 클래스 내에서 정의하는 것을 의미한다.
 이들 메서드는 이름과 매개변수 타입, 개수, 순서로 구분한다.
 메서드 오버로딩은 정적 다형성을 구현한다.
 2-2.반면, '메서드 오버라이딩'은 상속관계에서 발생한다.
 자식클래스가 부모클래스의 메서드를 재정의하는 것을 의미한다.
 메서드 시그니처가 동일해야하며 리턴타입도 같아야한다.
 자식클래스의 오버라이딩된 메서드가 호출된다.
 메서드 오버라이딩은 동적 다형성을 구현한다.

 이때, 정적 다형성은 컴파일 시간에 발생하는 다형성이고, 동적 다형성은 런타임 시간에 발생하는 다형성이다.
 메서드 오버라이딩이 런타임시간에 검사하는 이유는 유지보수 차원에서 유연성과 확장성을 넓이기 위함이다.
 부모클래스를 수정할 때 자식클래스에서 오버라이딩 된 메서드를 모두 다시 컴파일 해야한다. 이런 이유로
 런타임시간에 검사하게 된다면 부모클래스의 변경이 자식클래스에 영향을 주지 않고 유지할 수 있게 된다.
 (강의)
 0.이는 High level 코딩을 할 수 있고 사용자가 consistency를 유지할 수 있게 되어서 코드 수정을 안해도 된다.
 low level의 수준을 몰라도 되는게 유연성과 확장성을 가져오게 된다.
 1.오버라이딩이란, 부모클래스에서 선언된 메서드를 각 자식클래스에서 자신만의 내용으로 새로 구현하는 기능을 의미한다.
 2.상속을 통해 하나의 인터페이스(같은 이름)에 서로 다른 내용 구현이라는 객체지향의 다형성을 실현할 수 있다.
 Line클래스에서는 draw()는 선을 그리고
 Circle클래스에서는 draw()는 원을 그리고
 Rect클래스에서는 draw()는 사각형을 그릴 수 있게 된다.
----------Chap05-2
1.추상클래스는 객체를 생성할 수 없다. 그 이유는 불완전한 객체가 만들어지기 때문이다.
이러한 이유로 자식클래스는 오버라이딩으로 반드시 구현해야 객체를 생성할 수 있다.
2.추상메서드가 하나라도 있으면 해당 클래스는 반드시 abstract를 사용해야한다.
3.추상메서드란 선언은 되어있으나 구현이 안되어 있는 메서드이다.
4.객체를 직접 생성하지는 못하지만 참조변수의 타입으로는 줄 수 있다.
5.Override 어노테이션을 사용하면
오타와 같은 실수를 잡을 수 있다.
생각보다 오버라이딩할 때 실수가 많기 때문에
사용하는 습관을 갖는게 좋다.
6.자식클래스에서 오버라이딩할 때 abstract이 없어도 된다.
7.추상클래스는 설계 단계에서 구현하지 않는다.
추상메서드를 작성하게 되면 어떻게 보면 불필요할지 모르지만
이는 자식클래스에서 오버라이딩할 때 해당 기능이 보장이되어서
설계 단계에서 추상메서드 사용이 좋다.
8.인터페이스란 추상메서드로만 구현된 추상클래스를 의미한다.
기본적으로 추상클래스의 기능을 국한시킨게 인터페이스이다.
9.인터페이스는 여러 기능을 제한시켜 다중상속을 가능하게 한다.
10.default, private, static 메서드도 인터페이스에 포함되는데
이는 모두 공통점으로 중간에 달라지는게 없다는 것이다.
11.인터페이스는 필드를 선언할 수 없다. 상수만 가능하다.
필드를 선언하게 된다면 다중상속의 의미가 사라지게 된다.
12.인터페이스는 class대신 그 자리에 interface를 사용한다.
자식클래스가 인터페이스를 상속받으면 extends 대신 implememts를 사용하고
여러게의 인터페이스를 다중상속 받을 수 있다.
13.또한, 인터페이스 안에서 public, static, abstract를 생략할 수 있고,
기본적으로 public으로 생각하면 된다.
14.이때 메서드에 default가 사용되면 자식클래스에서 불필요한 오버라이딩을 생략할 수 있어서
코딩의 피로감을 줄일 수 있다.
15.또한, 오버라이딩은 접근 권한을 줄일 수 있다.
부모 인터페이스가 public이면 자식 인터페이스는 private으로 접근 권한을 줄일 수 없다.
다만, 줄일 수는 없지만 늘릴 수는 있다.
16.추상클래스는 객체 생성이 불가능하고 타입의 레퍼런스 변수 선언이 가능하다.
17.일반 클래스에서는 상속 받는다라고 표현하고 인터페이스는 구현한다라고 부르며
두 단어간 의미는 같다.
18.오버라이딩을 반드시해야 객체 생성이 가능하다.
19.인터페이스는 규격만 제공하여 자식클래스에게 기능을 보장하게 한다.
규격을 통일시키고 내부적인 코드는 다르게가 가능하다.
20.인터페이스가 제공한 규격을 받은 자식들도 결국 인터페이스에서 제공받은 메서드는
부모가 된다. 이는 다형성과 관련이 있다.

#궁금한 점
abstract 클래스 내부에서
추상 메서드 없어도 가능?

#몰랐던 개념 정리
1.this.x = this.y = 0;이런 문법도 가능하다!


#문제풀이 개념정리
1.자식클래스의 객체 생성->부모클래스 생성자 호출->부모클래스 private 사용가능.

2.(중요)super()로 부모클래스의 private변수 생성했다면
자식에서의 접근은 바로 접근 안됨.
private은 오직 그 하나의 해당 클래스에서만 접근이 가능.
자식에서 접근하려면 간접적으로 메서드 호출에 의해 접근해야됨.

3.오버라이딩시
반드시 리턴타입, 메서드명, 매개변수 종류와 개수가 일치해야됨.
@Override를 붙이는 이유는 오버라이딩이 안되었을 때
컴파일러가 사용자에게 알려준다.







*/